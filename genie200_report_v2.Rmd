---
title: "Untitled"
author: "JeonJunho"
date: "2024-04-30"
output:
  word_document:
    pandoc_args: ["--lua-filter=allow-html.lua"] 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, echo=FALSE, message=FALSE}
library(tidyverse)
library(DT)
```

# Problem Forulation 

예전에, web craling practicing을 하면서 음악 사이트를 web crawling한 적이 있다.

그때, 재밌는 점이, 굉장히 옛날 노래들이 in200을 유지하고 있는 경우가 많이 보였다는 점이다.

이번 주제는 permanent music : 이 음악이 오래 살아남을 것인가 에 대해 categorical model을 세워보고자 한다.

------------------------------------------------------------------------

# Data Preparing

본인이 Genie music을 애용하기도 했고, crawling의 편의성을 이유로 genie를 선택했다.

(genie 사진)

```{r, echo=FALSE}
df1 <- read.table("C:/Users/p5682/Desktop/R_cloud/R_2024/DataMining_proj/genie200.txt")
df1 <- df1 %>% mutate(date = as.Date(date))
DT::datatable(head(df1, 10))
```

genie에서는 공식적으로 최근부터 2022년 1월 첫째주까지 in200 순위를 제공하고 있다. 사이트 주소를 임의로 변경해 이전 기록에도 접근 가능하지만, 일단 공식적으로 제공하는 정보만 이용하기로 결정하였다.

2022년 1월 첫째주부터 2024년 4월 첫째주까지 2년이 좀 넘는 dataset을 확보했다.

음원 순위의 기준은 주간으로 정했다. 일간은 dataset이 과도하게 많아질 것 같고, 하루 잠깐 올라왔다 떨어지는 음악이 많아 자료가 unstable하다고 생각했다. 또한 주간 순위라면 충분히 대표성이 있을 것이라고 생각했다.

variables는 title, artist, ranking, rankingdiff, date이다.

타겟 변수 Y는 isPermanent{0, 1}으로, "all-time date동안 in200을 만족하는가"가 조건이다.

EDA를 해보고 데이터(X)가 추가될수도 있고, 타겟변수의 디테일한 조건이 변경될 수도 있지만 일단은 이러하다.

------------------------------------------------------------------------

# EDA

```{r, echo=FALSE}
titles <- unique(df1$title) ; length(titles)
alive_date <- c()
ranking_list <- list()

# par(mfrow=c(2,2))
cnt <- 1 # cnt = 10
for(t in titles) {
  temp_df <- df1 %>% filter(title==t) # t=df1$title[15]
  alive_date <- c(alive_date, tibble(temp_df) %>% slice(c(1, n())) %>% .$date %>% diff.Date())
  ranking_list[[cnt]] <- temp_df$ranking
  # plot(ranking_list[[cnt]], type="l", main=titles[cnt])
  cnt = cnt+1
}
# par(mfrow=c(1,1))


ggplot(tibble(alive_date), aes(x = alive_date/7)) +
    geom_histogram(aes(y = after_stat(density)), bins = 30, alpha = 0.5, color = "white", fill = "skyblue") +  # histogram 그리기
    geom_density(alpha = 0.5, fill = "orange") +  # density plot 그리기
    # geom_rug(aes(x=alive_date/7+runif(length(alive_date), 0.01, 0.1))) +  # rug plot 그리기 (하단에)
    labs(title = "Histogram and Density Plot", x = "연속 in200 시기(단위 : 주)", y = "Density") # 제목과 축 레이블 설정
#
```

대부분의 음악들이 3주 이상을 버티지 못하고 in 200에서 벗어나는 모습을 관측할 수 있다.

또한, 전체 조회 기간동안 in200을 유지하는 음악이 group화되어 있는 모습을 확인할 수 있다.


```{r, echo=FALSE}
table_alive_date <- table(alive_date/7) ; 
# table_alive_date
df_alive_date <- tibble("in200 기간"=factor(names(table_alive_date),levels = as.numeric(names(table_alive_date))),
                        count=as.numeric(table_alive_date))
df_alive_date %>% arrange(desc(count))
```

생존 주간을 빈도표로 나타내면 다음과 같다. 
대부분이 3주 이상 in200에서 버티지 못하는 것이 보인다.
전체 기간에서 in200을 유지하는 곡이 특이하게 많이 보인다.


따라서, 예측변수 Y를 in200을 조회 기간(117주)동안 유지하는가 하지 못하는가에 초점을 둘 수도 있다.

하지만 Y를 117주 동안 in200으로 두면 문제가 생긴다. 바로 조회 기간동안 in200을 처음 기록한 음악들이다. 이런 음악들은 실제로 앞으로 계속 in200을 기록하게 되어도 permanent music에 속하지 못한다.

